
```{r, child="_setup.Rmd"}
```

```{r 601start, echo=FALSE, message=FALSE, results='hide'}
load("C:/Users/ljsinke/Documents/git/GitHub/test_workflow/data/targets_mod.RData")
RGset <- read.metharray.exp(base="C:/Users/ljsinke/Documents/r/cd/GSE113018/IDATs", targets, extended=TRUE)
GRset <- preprocessFunnorm.DNAmArray(RGset, nPCs=4, keepCN=FALSE)
RGset <- probeFiltering(RGset)
betas <- reduce(GRset, RGset, what="beta")
```

***

# Imputation #

Methylation profiles often contain multiple missing values, which can be assumed to be missing at random (MAR), since they are likely due to random experimental and technology-related errors, rather than associated with methylation status. 

Imputation of these values is beneficial for multiple algorithms, but its importance is highlighted in the use of predictors that rely on values from only a subset of CpGs. In these instances, the effect of a few missing sites could vastly alter estimated age, for example. 

DNA methylation values represent a limited-range continuous variable, for which many standard imputation methods are theoretically suitable. However, they struggle with larger datasets due to a lack of computational efficiency. For this reason, specific strategies have been developed to handle missing methylation data [@Mazumder2010, @Josse2012, @DiLena2019].

The method that we advise using is [**MethyLImp**](https://github.com/pdilena/methyLImp) [@DiLena2019], and we are in the process of developing a parallelized version of this for DNAmArray. This iterative algorithm exploits the high inter-sample correlation seen in methylation data [@Zhang2017], capturing it using linear regression. This method is both computationally efficient and has been shown to perform better than all current alternatives, whilst not requiring post-imputation truncation [@DiLena2019]. 

Until the parallelized version is available, we advise using `imputePCA()` from [**missMDA**](https://www.rdocumentation.org/packages/missMDA/versions/1.14) [@Josse2012]. This performs well for its small computation time, and does not suffer from the beta-value bias that `impute.knn()` has been shown to [@DiLena2019].

```{r 614nacount}
sum(is.na(betas))
```

After filtering and preprocessing, our beta-value matrix has 51,758 missing values. Using the code below, we can impute them by implementing a low-rank approximation version of the iterative EM-PCA algorithm [@Dempster1977]. Since this function can impute values outside the [0,1] range of beta-values, we apply a simple post-imputation truncation of the overflowed values. This has been shown not to significantly affect the accuracy [@DiLena2019].

```{r 614imputation}
library(missMDA)
betas <- imputePCA(betas)
betas <- betas$completeObs

betas[betas<0] <- 0
betas[betas>1] <- 1
```

***

# References #
