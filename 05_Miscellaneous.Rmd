
```{r, child="_setup.Rmd"}
```

```{r 601start, echo=FALSE, message=FALSE, results='hide'}
load("./data/targets.RData")
targets$Basename <- substring(targets$supplementary_file,68,95)
setwd("C:/Users/ljsinke/Documents/r/cd/IDATs")
library(minfi)
RGset <- read.metharray.exp(base=NULL, targets, extended=TRUE)
GRset <- invisible(preprocessFunnorm.DNAmArray(RGset, nPCs=4, keepCN=FALSE))
RGset <- probeFiltering(RGset)
betas <- reduce(GRset, RGset, what="beta")
betas <- invisible(probeMasking(betas, array="450", genome="hg19"))
```

***

# The `RangedSummarizedExperiment` class #

Moving further into the pipeline, it will be necessary to have our methylation data stored in a [`RangedSummarizedExperiment`](http://bioconductor.org/packages/SummarizedExperiment) class object. Designed to handle microarray data, this class stores observations from multiple samples alongside relevant meta-data, and ensures that both features and phenotypes are kept in-sync when subsetting.

This matrix-like container is organised with rows representing features, such as genes or exons, which can be accessed using `rowRanges()`. This function calls a `GRanges` object describing features and their attributes. The columns of the `RangedSummarizedExperiment` store information about each sample, and this can be accessed using `colData()`. 

Lastly, each assay is represented in the third dimension of this matrix-like object and can be shown using the `assays()` function. Meta-data is then linked to this combination of data frames, and can be accessed with the `metadata()` command. 

### Creating a `RangedSummarizedExperiment` ###

The [**FDb.InfiniumMethylation.hg19**](https://bioconductor.org/packages/release/data/annotation/html/FDb.InfiniumMethylation.hg19.html) package contains probe annotations, which can be extracted using the `getPlatform()` function. To ensure that we apply the previous prove filtering, we use `match()` to keep only the relevant information.

```{r 602probeannotate}
library(FDb.InfiniumMethylation.hg19)
rowRanges <- getPlatform(platform="HM450", genome="hg19")
rowRanges[1:10, 1:2]
rows <- match(rownames(betas), names(rowRanges))
```

Now that we have our annotations, we can combine them with our data using the [**SummarizedExperiment**](https://bioconductor.org/packages/release/bioc/html/SummarizedExperiment.html) package. After ensuring that any column subsetting is accounted for, we extract the `colData()` from our `RGset`. Finally, the beta values, probe annotations, and sample information is combines into a `RangedSummarizedExperiment` object using the `SummarizedExperiment()` function.

```{r 603summexp}
library(SummarizedExperiment)

cols <- match(colnames(betas), colnames(RGset))
colData <- colData(RGset[, cols])@listData

methData <- SummarizedExperiment(assays=SimpleList(beta=betas),
                                 rowRanges=rowRanges[rows], 
                                 colData = DataFrame(colData))
methData
```

You can read more about [**SummarizedExperiment**](http://bioconductor.org/packages/SummarizedExperiment) from the following resources:
1. [package vignette](http://bioconductor.org/packages/release/bioc/vignettes/SummarizedExperiment/inst/doc/SummarizedExperiment.html)
2. [course material](http://bioconductor.org/help/course-materials/2012/BiocEurope2012/SummarizedExperiment.pdf)
3. [BioConductor nature paper](http://www.nature.com/nmeth/journal/v12/n2/full/nmeth.3252.html)

***

# Phenotype Prediction #

It can be useful to predict phenotypes in your data, either for comparison to assumed categories or to help impute missing values. 

### Predict Sex ###

The [**DNAmArray**](https://github.com/molepi/DNAmArray) package contains a `getSex.DNAmArray()` function, which predicts the sex of your observations by inspecting intensities of X-chromosome signals. We use the `getBeta()` function from [**minfi**](https://bioconductor.org/packages/release/bioc/html/minfi.html) [@Aryee2014] as before to get the beta-value matrix and then use this to predict sex. Since some filtered probes may be used by the sex prediction function, we recalculate the beta matrix before prediction.

```{r 604sexpredict}
betas <- getBeta(RGset)
predicted <- getSex.DNAmArray(betas)
predicted <- as.character(factor(predicted))
table(predicted, useNA="always")
```

### Predict White Blood Cell Composition ###

White blood cell count can be predicted using Houseman's method [@Houseman2012] implemented in [**minfi**](http://bioconductor.org/packages/minfi) [@Jaffe2014] by the `estimateCellCounts()` function.

Alternatively, you can train your own predictor to impute white blood cell counts. In our example data, there is no cell count information for training, but the following code is a template that could be used. More information can be found about this at the [**wbccPredictor**](https://github.com/mvaniterson/wbccPredictor) GitHub.

First, beta values are obtained from the `RangedSummarizedExperiment` object, with CpGs where there are NA values removed. In this instance, there are 26,162 CpGs that have at least one NA, meaning that 396,580 remain.

```{r 605wbccload}
wbccData <- assays(methData)$beta
dim(wbccData)
wbccData[1:10, 1:2]

keep <- apply(wbccData, 1, function(x) all(!is.na(x)))
table(keep)
wbccData <- wbccData[keep, ]
dim(wbccData)
```

Then, known cell percentages are stored along with relevant covariates, such as age and sex. Complete data is then split into a training and test set, in order to build the predictor. It is possible to split the data using `sample()`, but then there is a risk that patterns in the data will be inherited by the training and test sets. Therefore, we employ stratified splitting using the `sample.split()` function from [**caTools**](https://cran.r-project.org/web/packages/caTools/index.html).

```{r 606wbccset, eval=FALSE}
cellPercentages <- as.data.frame(colData(methData)[ , c("Neut_Perc", "Lymph_Perc",
                                                        "Mono_Perc", "Eos_Perc",
                                                        "Baso_Perc")])
cellPercentages <- apply(cellPercentages, 2, as.numeric)

covariates <- as.data.frame(colData(methData))
covariates <- covariates[ , c("Age", "Sex")]
colnames(covariates) <- c("Age", "Sex")

rownames(covariates) <- rownames(cellPercentages) <- colnames(wbccData) <- colData(methData)$uuid
nas <- apply(cellPercentages, 1, function(x) any(is.na(x)))
complete <- which(!nas)

trainID <- sample.split(complete, SplitRatio=2/3)
testID <- complete[!(complete %in% trainID)]

dataTrain <- wbccData[ , trainID]
covarTrain <- covariates[trainID, ]
cellPercTrain <- cellPercentages[trainID, ]
```

Now that you have your training and test set, you can use the `train()` function from [**wbccPredictor**](https://github.com/mvaniterson/wbccPredictor) to build the predictor. This can then be saved and visualise before testing and use.

```{r 607wbccbuild, eval=FALSE}
wbccPredictor <- train(dataTrain, covarTrain, cellPerTrain, ncomp=50, validation="CV")
save(wbccPredictor)

summary(wbccPredictor)
cumsum(explvar(wbccPredictor))
barplot(cumsum(explvar(wbccPredictor)), las=2, ylab="Cumulative Variance Explained")
```

A validation plot is a method to select the number of components to use with the predictor. In the example below, we use 10 components, and then visualise the results with the `plotting()` function.

```{r 608wbccplot, eval=FALSE}
validationplot(predictor, val.type="R2")
predicted <- 10^wbccPredictor$fitted.values[ , , 20]-1
measured <- cellPerTrain

plotting <- function(measured, predicted, xlab="predicted", ylab="measured")
{
  op <- par(mfcol=c(3,2), mar=c(4,4,3,1))
  for(k in 1:ncol(measured))
  {
    type <- colnames(measured)[k]
    cme <- cor(predicted[ , k], measured[ , k])
    plot(predicted[ , k], measured[ , k], main=paste(type, " (correlation: ", round(cme,4), ")",
                                                     sep=""), bty="n", pty="s")
    abline(lm(measured[ , k]~0+predicted[ , k]), col=2, lty=1, lwd=2)
    abline(0, 1, col="grey", lty=1, lwd=2)
    grid()
  }
  par(op)
}

plotting(measured, predicted)
```

Using the test set, the predictor can be tested before using for `prediction()`.

```{r 609wbcctest, eval=FALSE}
dataTest <- wbccData[ , testID]
covarTest <- covariated[testID, ]
cellPerTest <- cellPercentages[testID, ]

predicted <- prediction(predictor, dataTest, covarTest, ncomp=20)
plotting(cellPerTest, predicted)
```

### Predict chronological age ###

Age can be predicted using Horvath's or Hannum's coefficients with `agep()` from [**wateRmelon**](https://bioconductor.org/packages/release/bioc/html/wateRmelon.html) [@Pidsley2013]. If you use Hannum's, you will need to call the coefficients using `data(hannumCoef)` before prediction.

```{r 610agep, message=FALSE, warning=FALSE}
library(wateRmelon)
agep <- agep(betas, method="horvath")
library(psych)
describe(agep[1:36])
describe(agep[37:56])
```

The above two summaries are for autopsy and healthy individuals respectively. In the paper [@Slieker2013], it states that the mean age for cadavers was 65.5 years with an SD of 7.2. The mean age for healthy volunteers was 28 years with an SD of 6.1. The above shows that age predictions using methylation data can be inaccurate and should not be treated as definitive. 

***

# Checking Sample Relationships #

Beta-values of the probes containing SNPs can be extracted from the RGset using [**minfi**](http:/bioconductor.org/packages/minfi)'s `getSnpBeta` function. These can then be converted to alleles using k-means clustering using the `genki()` function from [**wateRmelon**](https://bioconductor.org/packages/release/bioc/html/wateRmelon.html). This function returns values of disperson for each of three genotype peaks (AA, AB, and BB). which can be used as a performance metric since technical variation would decrease the tightness of the genotypic peaks.

```{r 611getsnps, eval=FALSE}
library(wateRmelon)
snpBetas <- getSnpBeta(RGset)
snpBetasVar <- genki(snpBetas)
```

[**omicsPrint**](http://bioconductor.org/packages/release/bioc/html/omicsPrint.html) [@Iterson2018] is a package we developed to detect data linkage errors through inspecting sample relations in multiple omics studies. This example uses data where individuals are unrelated, but if you have data on twins, for example, it would detect that and also show any mismatches.

Included with the package is the `hm450.manifest.pop.GoNL` data, which stores SNP probe information in a `GRanges` class object. This is then used to create a subset of the beta values for genotyping. 

```{r 612omicsprint, message=FALSE, warning=FALSE}
library(omicsPrint)
data(hm450.manifest.pop.GoNL)
cpgs <- names(hm450.manifest.pop.GoNL[mcols(hm450.manifest.pop.GoNL)$MASK.snp5.EAS])
cpgs <- na.omit(match(cpgs, rownames(betas)))
omicsBetas <- betas[cpgs,]
omicsBetas[1:10, 1:2]
```

The function `beta2genotype()` then genotypes the observations by measuring homozygous or heterozygous alleles at these SNP probes. Lastly `alleleSharing()` assesses the relationships between different individuals, which can be unrelated, twins, or identical. The results can then be visualised using the `inferRelations()` function.

```{r 613genotype}
dnamCalls <- beta2genotype(omicsBetas, assayName="exprs")
dim(dnamCalls)
dnamCalls[1:10, 1:2]

omicsData <- alleleSharing(dnamCalls, verbose=TRUE)
mismatches <- inferRelations(omicsData)
```

***

# Imputating NA Values #

Several algorithms do not allow NA's but beta-values and or M-values can contain NA's after preprocessing. Either because some probes/CpG were specifically set NA or because of transformation from intensities to beta or M-values. The [**impute**](https://bioconductor.org/packages/release/bioc/html/impute.html) [@Troyanskaya2001] package can be used to impute these values. Below, we use the knn approach implemented by `impute.knn()` from this package.

```{r 614imputation, results='hide'}
library(impute)
betas <- impute.knn(as.matrix(betas))$data
```

***

# Probe Annotation #

Our package also contains a `cpgInfo()` function, which can be used to map CpG probes to their nearest genes. This utilises the [**TxDb.Hsapiens.UCSC.hg19.knownGene**](http://bioconductor.statistik.tu-dortmund.de/packages/3.6/data/annotation/html/TxDb.Hsapiens.UCSC.hg19.knownGene.html) package, which accesses the USCS annotation databases.

```{r 615annotate}
cpgs <- rownames(betas)
cpgInfo <- cpgInfo(cpgs, TxDb="TxDb.Hsapiens.UCSC.hg19.knownGene")
cpgInfo[1:10, 1:7]
```

***

# DMR finder #

We have implemented a differentially methylated region (DMR) finder in the function `DMRfinder()` [@Slieker2013]. First, genomic features are extracted from the relevant `FeatureDb` as a `GRanges` object.

```{r eval=FALSE}
feats <- features(FDb.InfiniumMethylation.hg19)
regions <- feats[seqnames(feats) %in% c("chr21", "chr22")]
mcols(regions)  <- NULL
mcols(regions)$crit <- rbinom(length(regions), 1, prob=0.2)

##input GRanges
(dmrsR <- DMRfinder(regions))

##input named-vector
dmps <- mcols(regions)$crit
names(dmps) <- names(regions)
(dmrsV <- DMRfinder(dmps))

##bed-like data.frame
regions <- as.data.frame(regions)
regions <- regions[, c("seqnames", "start", "crit")]
colnames(regions) <- c("chr", "pos", "crit")
(dmrsD <- DMRfinder(regions))

##all equal
length(dmrsR)
length(dmrsV)
length(dmrsD)

head(dmrsR)
head(dmrsV)
head(dmrsD)

dmrsR == dmrsV
dmrsR == dmrsD
dmrsV == dmrsD
```

***

# References #
