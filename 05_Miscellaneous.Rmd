
```{r, child="_setup.Rmd"}
```

```{r 601start, echo=FALSE, message=FALSE, results='hide'}
load("C:/Users/ljsinke/Documents/git/GitHub/test_workflow/data/targets_mod.RData")
RGset <- read.metharray.exp(base="C:/Users/ljsinke/Documents/r/cd/GSE113018/IDATs", targets, extended=TRUE)
GRset <- preprocessFunnorm.DNAmArray(RGset, nPCs=4, keepCN=FALSE)
RGset <- probeFiltering(RGset)
betas <- reduce(GRset, RGset, what="beta")
betas <- probeMasking(betas, array="450", genome="hg19")
```

***

# Phenotype Prediction #

It can be useful to predict phenotypes in your data, either for comparison to assumed categories or to help impute missing values. We are in the process of creating predictors for sample cell composition, sex, age, and smoking status. These will either be reference-based predictors using the large BIOS data, which includes samples from 6 dutch cohorts and over 4000 individuals, or ones built using reference-free or semi-supervised methods. 

When created and distributed within this package, you will be able to use them to predict phenotypes in your own datasets. Meanwhile, below some current methods are describe to predict phenotypes in your data.

### Predict White Blood Cell Composition ###

White blood cell count can be predicted using Houseman's partial least squares method [@Houseman2012] implemented in [**minfi**](http://bioconductor.org/packages/minfi) [@Feinberg2014] by the `estimateCellCounts()` function. This implements a calibration algorithm for deconvoluting heterogenous tissue sources, such as blood, and returns a matrix of composition estimates across all samples and cell types. 

### Predict Sex ###

The [**DNAmArray**](https://github.com/molepi/DNAmArray) package contains a `getSex.DNAmArray()` function, which predicts the sex of your observations by inspecting intensities of X-chromosome signals. We use the `getBeta()` function from [**minfi**](https://bioconductor.org/packages/release/bioc/html/minfi.html) as before to get the beta-value matrix and then use this to predict sex. Since some filtered probes may be used by the sex prediction function, we recalculate the beta matrix before prediction.

```{r 604sexpredict}
betas_sex <- getBeta(RGset)
mid <- match(colnames(betas_sex), targets$Basename)

predictedSex <- as.factor(getSex.DNAmArray(betas_sex))
assumedSex <- targets$sex[mid]

table(predictedSex, assumedSex)
```

As you can see, this is complete data, but the predicted and assumed sexes are identical. This means that we can feel increased confidence that no incorrect labelling or mix-ups are present in this variable.

### Predict chronological age ###

Age can be predicted using Horvath's or Hannum's coefficients with `agep()` from [**wateRmelon**](https://bioconductor.org/packages/release/bioc/html/wateRmelon.html). If you use Hannum's, you will need to call the coefficients using `data(hannumCoef)` before prediction. The predicted and assumed ages are then combined into a data frame that can be used to visualize the results.

```{r 610agep, message=FALSE, warning=FALSE}
library(wateRmelon)
predictedAge <- as.numeric(agep(betas, method="horvath"))
assumedAge <- as.numeric(targets$age[mid])

ages <- data.frame(Assumed=assumedAge, Predicted=predictedAge)
head(ages)
```

```{r 610theme, echo=FALSE}
th3 <- theme(text=element_text(size=12), 
             panel.border=element_rect(fill=NA, color="#cdcdcd", size=1, linetype=1), 
             plot.title=element_text(size=20, hjust=0.5, margin=margin(0,0,15,0)), 
             plot.margin=margin(20,25,25,25))
```

```{r 610plot}
ggplot(ages, aes(x=Assumed, y=Predicted)) + ggtitle("Assumed vs. Predicted Age") + th3 +
  geom_point(shape=16, color="#158cba") + geom_smooth(method=lm, color="#D67D87")
```

The above graph shows that this prediction follows the general trend of the assumed ages, however the residuals are quite large. It may be possible to develop an improved predictor [@Zhang2018], and we plan to implement this.

***

# `RangedSummarizedExperiment` #

Moving further into the pipeline, it will be necessary to have our methylation data stored in a [`RangedSummarizedExperiment`](http://bioconductor.org/packages/SummarizedExperiment) class object. Designed to handle microarray data, this class stores observations from multiple samples alongside relevant meta-data, and ensures that both features and phenotypes are kept in-sync when subsetting.

This matrix-like container is organised with rows representing features, such as genes or exons, which can be accessed using `rowRanges()`. This function calls a `GRanges` object describing features and their attributes. The columns of the `RangedSummarizedExperiment` store information about each sample, and this can be accessed using `colData()`. 

Lastly, each assay is represented in the third dimension of this matrix-like object and can be shown using the `assays()` function. Meta-data is then linked to this combination of data frames, and can be accessed with the `metadata()` command. 

### Creating a `RangedSummarizedExperiment` ###

The [**FDb.InfiniumMethylation.hg19**](https://bioconductor.org/packages/release/data/annotation/html/FDb.InfiniumMethylation.hg19.html) package contains probe annotations, which can be extracted using the `getPlatform()` function. To ensure that we apply the previous probe filtering, we use `match()` to keep only the relevant information.

```{r 602probeannotate}
library(FDb.InfiniumMethylation.hg19)
rowRanges <- getPlatform(platform="HM450", genome="hg19")
rows <- match(rownames(betas), names(rowRanges))
rowRanges <- rowRanges[rows]

rowRanges[,3:4]
```

Now that we have our annotations, we can combine them with our data using the [**SummarizedExperiment**](https://bioconductor.org/packages/release/bioc/html/SummarizedExperiment.html) package. After ensuring that any column subsetting is accounted for, we extract the `colData()` from our `RGset`. Finally, the beta values, probe annotations, and sample information are combined into a `RangedSummarizedExperiment` object using the `SummarizedExperiment()` function.

```{r 603summexp}
library(SummarizedExperiment)

cols <- match(colnames(betas), colnames(RGset))
colData <- DataFrame(colData(RGset[, cols])@listData)

methData <- SummarizedExperiment(assays=SimpleList(betas=betas),
                                 rowRanges=rowRanges,
                                 colData=colData)
methData
```

You can read more about [**SummarizedExperiment**](http://bioconductor.org/packages/SummarizedExperiment) from the following resources:
<ul>
<li>[package vignette](http://bioconductor.org/packages/release/bioc/vignettes/SummarizedExperiment/inst/doc/SummarizedExperiment.html)</li>
<li>[course material](http://bioconductor.org/help/course-materials/2012/BiocEurope2012/SummarizedExperiment.pdf)</li>
<li>[BioConductor nature paper](http://www.nature.com/nmeth/journal/v12/n2/full/nmeth.3252.html)</li>
</ul>

***

# Checking Sample Relationships #

Beta-values of the probes containing SNPs can be extracted from the RGset using [**minfi**](http:/bioconductor.org/packages/minfi)'s `getSnpBeta` function. These can then be converted to alleles using k-means clustering using the `genki()` function from [**wateRmelon**](https://bioconductor.org/packages/release/bioc/html/wateRmelon.html). This function returns values of disperson for each of three genotype peaks (AA, AB, and BB). which can be used as a performance metric since technical variation would decrease the tightness of the genotypic peaks.

```{r 611getsnps, eval=FALSE}
library(wateRmelon)
snpBetas <- getSnpBeta(RGset)
snpBetasVar <- genki(snpBetas)
```

***

# Imputating NA Values #

Several algorithms do not allow NA's but beta-values and or M-values can contain NA's after preprocessing. Either because some probes/CpG were specifically set NA or because of transformation from intensities to beta or M-values. The [**impute**](https://bioconductor.org/packages/release/bioc/html/impute.html) package can be used to impute these values. Below, we use the knn approach implemented by `impute.knn()` from this package.

```{r 614imputation, results='hide'}
library(impute)
betas <- impute.knn(as.matrix(betas))$data
```

***

# Probe Annotation #

Our package also contains a `cpgInfo()` function, which can be used to map CpG probes to their nearest genes. This utilises the [**TxDb.Hsapiens.UCSC.hg19.knownGene**](http://bioconductor.statistik.tu-dortmund.de/packages/3.6/data/annotation/html/TxDb.Hsapiens.UCSC.hg19.knownGene.html) package, which accesses the USCS annotation databases.

```{r 615annotate}
cpgs <- rownames(betas)
cpgInfo <- cpgInfo(cpgs, TxDb="TxDb.Hsapiens.UCSC.hg19.knownGene")
cpgInfo[1:10, 1:7]
```

***

# References #
