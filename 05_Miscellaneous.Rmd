
```{r, child="_setup.Rmd"}
```

```{r echo=FALSE, message=FALSE, results='hide'}
load("./data/targets.RData")
targets$Basename <- substring(targets$supplementary_file,68,95)
setwd("C:/Users/Lu/Documents/IDATs")
library(minfi)
RGset <- read.metharray.exp(base=NULL, targets, extended=TRUE)
GRset <- invisible(preprocessFunnorm.DNAmArray(RGset, nPCs=4, keepCN=FALSE))
RGset <- probeFiltering(RGset)
mvalues <- reduce(GRset, RGset, what="M")
mvalues <- invisible(probeMasking(mvalues, array="450", genome="hg19"))
```

***

# The `SummarizedExperiment` class #

Moving further into the pipeline, it will be necessary to have our methylation data stored in a [`SummarizedExperiment`](http://bioconductor.org/packages/SummarizedExperiment) class object. Designed to handle microarray data, this class stores observations from multiple samples alongside relevant meta-data, and ensures that both features and phenotypes are kept in-sync when subsetting.

This matrix-like container is organised with rows representing features, such as genes or exons, which can be accessed using `rowData()`. This function calls a 2-dimensional data frame with features as rows and attributes of these features, such as transcript IDs, as columns. The columns of the `SummarizedExperiment` store information about each sample, and this can be accessed using `colData()`. 

Lastly, each assay is represented in the third dimension of this matrix-like object and can be shown using the `assays()` function. Meta-data is then linked to this combination of data frames, and can be accessed with the `metadata()` command. 



Using the `getPlatform()` function from [**FDb.InfiniumMethylation.hg19**](https://bioconductor.org/packages/release/data/annotation/html/FDb.InfiniumMethylation.hg19.html), we can annotate the probes. 

```{r}
library(FDb.InfiniumMethylation.hg19)
rowRanges <- getPlatform(platform="HM450", genome="hg19")
rowRanges
```

> Need to fully understand this

```{r se.colannotation, message=FALSE, results='hide', eval=FALSE}
library(BBMRIomics)
pheno <- getView("allPhenotypes", usrpwd=RP3_MDB_USRPWD, url=RP3_MDB)
colData <- merge(pheno, targets, by="ids", all.y=TRUE)
rownames(colData) <- colData$run_id
```
```{r se.coldata, eval=FALSE}
colData[1:5, 1:5]
```

```{r se.sumexp, eval=FALSE}
mvalues <- makeSE(mvalues, colData, rowRanges, note="Functional Normalized and knn imputed")
mvalues
```

You can read more about [**SummarizedExperiment**](http://bioconductor.org/packages/SummarizedExperiment) from the following resources:
1. [package vignette](http://bioconductor.org/packages/release/bioc/vignettes/SummarizedExperiment/inst/doc/SummarizedExperiment.html)
2. [course material](http://bioconductor.org/help/course-materials/2012/BiocEurope2012/SummarizedExperiment.pdf)
3. [BioConductor nature paper](http://www.nature.com/nmeth/journal/v12/n2/full/nmeth.3252.html)

***

***

# Phenotype Prediction #

It can be useful to predict phenotypes in your data, either for comparison to assumed categories or to help impute missing values. 

### Predict Sex ###

The [**DNAmArray**](https://github.com/molepi/DNAmArray) package contains a `getSex.DNAmArray()` function, which predicts the sex of your observations by inspecting intensities of X-chromosome signals. We use the `getBeta()` function from [**minfi**](https://bioconductor.org/packages/release/bioc/html/minfi.html) [@Aryee2014] as before to get the beta-value matrix and then use this to predict sex. If the beta matrix has already undergone probe filtering, it is important to recalculate it as some filtered probes may be used by the sex prediction function.

```{r}
betas <- getBeta(RGset)
predicted <- getSex.DNAmArray(betas)
predicted <- as.character(factor(predicted))
table(predicted, useNA="always")
```

### Predict White Blood Cell Composition ###

> This function needs adapting for DNAmArray

White blood cell count can be predicted using Houseman's method[@Houseman2012] implemented in the [**minfi**](http://bioconductor.org/packages/minfi)[@Jaffe2014].

See also our approach for the imputation of white blood cell counts:[wbccPredictor](https://github.com/mvaniterson/wbccPredictor)

> Create new functions to predict other phenotypes, such as chronological age or smoking status.

***

# Checking Sample Relationships #

Beta-values of the probes containing SNPs can be extracted from the RGset using [**minfi**](http:/bioconductor.org/packages/minfi)'s `getSnpBeta` function. These can then be converted to alleles using k-means clustering using the `genki()` function from [**wateRmelon**](https://bioconductor.org/packages/release/bioc/html/wateRmelon.html) [@Pidsley2013]. This function returns values of disperson for each of three genotype peaks (AA, AB, and BB). which can be used as a performance metric since technical variation would decrease the tightness of the genotypic peaks.

```{r getsnps, eval=FALSE}
library(wateRmelon)
snpBetas <- getSnpBeta(RGset)
snpBetasVar <- genki(snpBetas)
```

> use omicsPrint

***

# Imputating NA Values #

Several algorithms do not allow NA's but beta-values and or M-values can contain NA's after preprocessing. Either because some probes/CpG were specifically set NA or because of transformation from intensities to beta or M-values. The [**impute**]https://bioconductor.org/packages/release/bioc/html/impute.html) package can be used to impute these values. Below, we use the knn approach implemented by `impute.knn()` from the [**impute**] package [@Troyanskaya2001].

```{r imputation, results='hide'}
library(impute)
mvalues <- impute.knn(as.matrix(mvalues))$data
```

***

# Probe Annotation #

Our packages contains a `cpgInfo()` function, which can be used to map CpG probes to their nearest genes. 

```{r}
cpgs <- rownames(mvalues)
cpgInfo <- cpgInfo(cpgs, TxDb="TxDb.Hsapiens.UCSC.hg19.knownGene")
```



# DMR finder #

In our packages, we have implemented a DMR finder in the function `DMRfinder()` [@Slieker2013]. First, genomic features are extracted from the relevant `FeatureDb` object

> Again, I need to look into this

```{r eval=FALSE}
feats <- features(FDb.InfiniumMethylation.hg19)
regions <- feats[seqnames(feats) %in% c("chr21", "chr22")]
mcols(regions)  <- NULL
mcols(regions)$crit <- rbinom(length(regions), 1, prob=0.2)

##input GRanges
(dmrsR <- DMRfinder(regions))

##input named-vector
dmps <- mcols(regions)$crit
names(dmps) <- names(regions)
(dmrsV <- DMRfinder(dmps))

##bed-like data.frame
regions <- as.data.frame(regions)
regions <- regions[, c("seqnames", "start", "crit")]
colnames(regions) <- c("chr", "pos", "crit")
(dmrsD <- DMRfinder(regions))

##all equal
length(dmrsR)
length(dmrsV)
length(dmrsD)

head(dmrsR)
head(dmrsV)
head(dmrsD)

dmrsR == dmrsV
dmrsR == dmrsD
dmrsV == dmrsD
```

***

# References #
