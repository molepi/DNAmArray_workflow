
```{r, child="_setup.Rmd"}
```

```{r echo=FALSE, message=FALSE, results='hide'}
load("./data/targets.RData")
targets$Basename <- substring(targets$supplementary_file,68,95)
setwd("C:/Users/Lu/Documents/IDATs")
library(minfi)
RGset <- read.metharray.exp(base=NULL, targets, extended=TRUE)
GRset <- invisible(preprocessFunnorm.DNAmArray(RGset, nPCs=4, keepCN=FALSE))
RGset <- probeFiltering(RGset)
mvalues <- reduce(GRset, RGset, what="M")
mvalues <- probeMasking(mvalues, array="450", genome="hg19")
```

***

# Phenotype Prediction #

It can be useful to predict phenotypes in your data, either for comparison to assumed categories or to help impute missing values. 

### Predict Sex ###

The [**DNAmArray**](https://github.com/molepi/DNAmArray) package contains a `getSex.DNAmArray()` function, which predicts the sex of your observations by inspecting intensities of X-chromosome signals. We use the `getBeta()` function from [**minfi**](https://bioconductor.org/packages/release/bioc/html/minfi.html) [@Aryee2014] as before to get the beta-value matrix and then use this to predict sex. If the beta matrix has already undergone probe filtering, it is important to recalculate it as some filtered probes may be used by the sex prediction function.

```{r}
betas <- getBeta(RGset)
predicted <- getSex.DNAmArray(betas)
predicted <- as.character(factor(predicted))
table(predicted, useNA="always")
```

### Predict White Blood Cell Composition ###

> This function needs adapting for DNAmArray

White blood cell count can be predicted using Houseman's method[@Houseman2012] implemented in the [**minfi**](http://bioconductor.org/packages/minfi)[@Jaffe2014].

See also our approach for the imputation of white blood cell counts:[wbccPredictor](https://github.com/mvaniterson/wbccPredictor)

> Create new functions to predict other phenotypes, such as chronological age or smoking status.

***

# Checking Sample Relationships #

Beta-values of the probes containing SNPs can be extracted from the RGset using [**minfi**](http:/bioconductor.org/packages/minfi)'s `getSnpBeta` function. These can then be converted to alleles using k-means clustering using the `genki()` function from [**wateRmelon**](https://bioconductor.org/packages/release/bioc/html/wateRmelon.html) [@Pidsley2013]. This function returns values of disperson for each of three genotype peaks (AA, AB, and BB). which can be used as a performance metric since technical variation would decrease the tightness of the genotypic peaks.

```{r getsnps, eval=FALSE}
library(wateRmelon)
snpBetas <- getSnpBeta(RGset)
snpBetasVar <- genki(snpBetas)
```

> since relabelgenotypes() is deprecated, we need a new way to discover swaps. In the previous version, all DNA samples were correlated with each other to check for unreported relatedness. From the genotypes, identity-by-state was calculated for each SNP and these were summarized by mean and variance. This used the alleleSharing() function from omicsPrint, and was based on an idea from GRR-tool for the detection of sample relationships in genotype data.

***

# Imputating NA Values #

Several algorithms do not allow NA's but beta-values and or M-values can contain NA's after preprocessing. Either because some probes/CpG were specifically set NA or because of transformation from intensities to beta or M-values. The [**impute**]https://bioconductor.org/packages/release/bioc/html/impute.html) package can be used to impute these values. Below, we use the knn approach implemented by `impute.knn()` from the [**impute**] package [@Troyanskaya2001].

```{r imputation, results='hide'}
library(impute)
mvalues <- impute.knn(as.matrix(mvalues))$data
```

***

# Probe Annotation #

Our packages contains a `cpgInfo()` function, which can be used to map CpG probes to their nearest genes. 

```{r}
cpgs <- rownames(mvalues)
cpgInfo <- cpgInfo(cpgs, TxDb="TxDb.Hsapiens.UCSC.hg19.knownGene")
```

***

# Construct `SummarizedExperiment` containing DNA methylation data #

It is useful to store the normalized beta- or M-values together with metadata on samples and features as a [**SummarizedExperiment**](http://bioconductor.org/packages/SummarizedExperiment) class object. Using the `getPlatform()` function from [**FDb.InfiniumMethylation.hg19**](https://bioconductor.org/packages/release/data/annotation/html/FDb.InfiniumMethylation.hg19.html), we can annotate the probes. 

```{r}
library(FDb.InfiniumMethylation.hg19)
rowRanges <- getPlatform(platform="HM450", genome="hg19")
rowRanges
```

> Need to fully understand this

```{r se.colannotation, message=FALSE, results='hide', eval=FALSE}
library(BBMRIomics)
pheno <- getView("allPhenotypes", usrpwd=RP3_MDB_USRPWD, url=RP3_MDB)
colData <- merge(pheno, targets, by="ids", all.y=TRUE)
rownames(colData) <- colData$run_id
```
```{r se.coldata, eval=FALSE}
colData[1:5, 1:5]
```

```{r se.sumexp, eval=FALSE}
mvalues <- makeSE(mvalues, colData, rowRanges, note="Functional Normalized and knn imputed")
mvalues
```

You can read more about [**SummarizedExperiment**](http://bioconductor.org/packages/SummarizedExperiment) from the following resources:
1. [package vignette](http://bioconductor.org/packages/release/bioc/vignettes/SummarizedExperiment/inst/doc/SummarizedExperiment.html)
2. [course material](http://bioconductor.org/help/course-materials/2012/BiocEurope2012/SummarizedExperiment.pdf)
3. [BioConductor nature paper](http://www.nature.com/nmeth/journal/v12/n2/full/nmeth.3252.html)

***

# DMR finder #

In our packages, we have implemented a DMR finder in the function `DMRfinder()` [@Slieker2013]. First, genomic features are extracted from the relevant `FeatureDb` object

> Again, I need to look into this

```{r eval=FALSE}
feats <- features(FDb.InfiniumMethylation.hg19)
regions <- feats[seqnames(feats) %in% c("chr21", "chr22")]
mcols(regions)  <- NULL
mcols(regions)$crit <- rbinom(length(regions), 1, prob=0.2)

##input GRanges
(dmrsR <- DMRfinder(regions))

##input named-vector
dmps <- mcols(regions)$crit
names(dmps) <- names(regions)
(dmrsV <- DMRfinder(dmps))

##bed-like data.frame
regions <- as.data.frame(regions)
regions <- regions[, c("seqnames", "start", "crit")]
colnames(regions) <- c("chr", "pos", "crit")
(dmrsD <- DMRfinder(regions))

##all equal
length(dmrsR)
length(dmrsV)
length(dmrsD)

head(dmrsR)
head(dmrsV)
head(dmrsD)

dmrsR == dmrsV
dmrsR == dmrsD
dmrsV == dmrsD
```

***

# References #
