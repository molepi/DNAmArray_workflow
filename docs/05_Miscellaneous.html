<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title></title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/spacelab.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 52px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 57px;
  margin-top: -57px;
}
.section h2 {
  padding-top: 57px;
  margin-top: -57px;
}
.section h3 {
  padding-top: 57px;
  margin-top: -57px;
}
.section h4 {
  padding-top: 57px;
  margin-top: -57px;
}
.section h5 {
  padding-top: 57px;
  margin-top: -57px;
}
.section h6 {
  padding-top: 57px;
  margin-top: -57px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->



<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">DNAmArray</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="01_SampleQualityControl.html">Quality control</a>
</li>
<li>
  <a href="02_Visualization.html">Visualizations</a>
</li>
<li>
  <a href="03_Normalization.html">Normalization</a>
</li>
<li>
  <a href="04_ProbeFiltering.html">Probe filtering</a>
</li>
<li>
  <a href="05_Miscellaneous.html">Miscellaneous</a>
</li>
<li>
  <a href="06_EWAS.html">Ewas</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="about.html">About</a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">




</div>


<hr />
<div id="the-rangedsummarizedexperiment-class" class="section level1">
<h1>The <code>RangedSummarizedExperiment</code> class</h1>
<p>Moving further into the pipeline, it will be necessary to have our methylation data stored in a <a href="http://bioconductor.org/packages/SummarizedExperiment"><code>RangedSummarizedExperiment</code></a> class object. Designed to handle microarray data, this class stores observations from multiple samples alongside relevant meta-data, and ensures that both features and phenotypes are kept in-sync when subsetting.</p>
<p>This matrix-like container is organised with rows representing features, such as genes or exons, which can be accessed using <code>rowRanges()</code>. This function calls a <code>GRanges</code> object describing features and their attributes. The columns of the <code>RangedSummarizedExperiment</code> store information about each sample, and this can be accessed using <code>colData()</code>.</p>
<p>Lastly, each assay is represented in the third dimension of this matrix-like object and can be shown using the <code>assays()</code> function. Meta-data is then linked to this combination of data frames, and can be accessed with the <code>metadata()</code> command.</p>
<div id="creating-a-rangedsummarizedexperiment" class="section level3">
<h3>Creating a <code>RangedSummarizedExperiment</code></h3>
<p>The <a href="https://bioconductor.org/packages/release/data/annotation/html/FDb.InfiniumMethylation.hg19.html"><strong>FDb.InfiniumMethylation.hg19</strong></a> package contains probe annotations, which can be extracted using the <code>getPlatform()</code> function. To ensure that we apply the previous prove filtering, we use <code>match()</code> to keep only the relevant information.</p>
<pre class="r"><code>library(FDb.InfiniumMethylation.hg19)
rowRanges &lt;- getPlatform(platform=&quot;HM450&quot;, genome=&quot;hg19&quot;)</code></pre>
<pre><code>## Fetching coordinates for hg19...</code></pre>
<pre class="r"><code>rowRanges[1:10, 1:2]</code></pre>
<pre><code>## GRanges object with 10 ranges and 2 metadata columns:
##              seqnames        ranges strand |    addressA    addressB
##                 &lt;Rle&gt;     &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt; &lt;character&gt;
##   cg04913815    chr16   60438-60439      * |    24771476            
##   cg01686861    chr16   60748-60749      * |    36644319    45624454
##   cg05558259    chr16   61085-61086      * |    65765435            
##   cg26978960    chr16   62460-62461      * |    28717484            
##   cg03792876    chr16   73243-73244      * |    42725455            
##   cg09699726    chr16   91602-91603      * |    34629364            
##   cg07549526    chr16   91663-91664      * |    65631352    31654409
##   cg02851049    chr16 101260-101261      * |    38765355            
##   cg11876012    chr16 101686-101687      * |    47645328            
##   cg14820573    chr16 102121-102122      * |    36735483            
##   -------
##   seqinfo: 24 sequences from hg19 genome</code></pre>
<pre class="r"><code>rows &lt;- match(rownames(betas), names(rowRanges))</code></pre>
<p>Now that we have our annotations, we can combine them with our data using the <a href="https://bioconductor.org/packages/release/bioc/html/SummarizedExperiment.html"><strong>SummarizedExperiment</strong></a> package. After ensuring that any column subsetting is accounted for, we extract the <code>colData()</code> from our <code>RGset</code>. Finally, the beta values, probe annotations, and sample information is combines into a <code>RangedSummarizedExperiment</code> object using the <code>SummarizedExperiment()</code> function.</p>
<pre class="r"><code>library(SummarizedExperiment)

cols &lt;- match(colnames(betas), colnames(RGset))
colData &lt;- colData(RGset[, cols])@listData

methData &lt;- SummarizedExperiment(assays=SimpleList(beta=betas),
                                 rowRanges=rowRanges[rows], 
                                 colData = DataFrame(colData))
methData</code></pre>
<pre><code>## class: RangedSummarizedExperiment 
## dim: 422742 56 
## metadata(0):
## assays(1): beta
## rownames(422742): cg01707559 cg03244189 ... ch.22.1008279F
##   ch.22.47579720R
## rowData names(10): addressA addressB ... probeEnd probeTarget
## colnames(56): GSM1179497_5729917059_R01C01
##   GSM1179498_5729917059_R01C02 ... GSM1179551_7310440085_R01C02
##   GSM1179552_7310440053_R03C02
## colData names(35): title geo_accession ... Basename filenames</code></pre>
<p>You can read more about <a href="http://bioconductor.org/packages/SummarizedExperiment"><strong>SummarizedExperiment</strong></a> from the following resources: 1. <a href="http://bioconductor.org/packages/release/bioc/vignettes/SummarizedExperiment/inst/doc/SummarizedExperiment.html">package vignette</a> 2. <a href="http://bioconductor.org/help/course-materials/2012/BiocEurope2012/SummarizedExperiment.pdf">course material</a> 3. <a href="http://www.nature.com/nmeth/journal/v12/n2/full/nmeth.3252.html">BioConductor nature paper</a></p>
<hr />
</div>
</div>
<div id="phenotype-prediction" class="section level1">
<h1>Phenotype Prediction</h1>
<p>It can be useful to predict phenotypes in your data, either for comparison to assumed categories or to help impute missing values.</p>
<div id="predict-sex" class="section level3">
<h3>Predict Sex</h3>
<p>The <a href="https://github.com/molepi/DNAmArray"><strong>DNAmArray</strong></a> package contains a <code>getSex.DNAmArray()</code> function, which predicts the sex of your observations by inspecting intensities of X-chromosome signals. We use the <code>getBeta()</code> function from <a href="https://bioconductor.org/packages/release/bioc/html/minfi.html"><strong>minfi</strong></a> <span class="citation">(Aryee et al. 2014)</span> as before to get the beta-value matrix and then use this to predict sex. Since some filtered probes may be used by the sex prediction function, we recalculate the beta matrix before prediction.</p>
<pre class="r"><code>betas &lt;- getBeta(RGset)
predicted &lt;- getSex.DNAmArray(betas)
predicted &lt;- as.character(factor(predicted))
table(predicted, useNA=&quot;always&quot;)</code></pre>
<pre><code>## predicted
## Female   Male   &lt;NA&gt; 
##     32     24      0</code></pre>
</div>
<div id="predict-white-blood-cell-composition" class="section level3">
<h3>Predict White Blood Cell Composition</h3>
<p>White blood cell count can be predicted using Houseman’s method <span class="citation">(Houseman et al. 2012)</span> implemented in <a href="http://bioconductor.org/packages/minfi"><strong>minfi</strong></a> <span class="citation">(Jaffe and Irizarry 2014)</span> by the <code>estimateCellCounts()</code> function.</p>
<p>Alternatively, you can train your own predictor to impute white blood cell counts. In our example data, there is no cell count information for training, but the following code is a template that could be used. More information can be found about this at the <a href="https://github.com/mvaniterson/wbccPredictor"><strong>wbccPredictor</strong></a> GitHub.</p>
<p>First, beta values are obtained from the <code>RangedSummarizedExperiment</code> object, with CpGs where there are NA values removed. In this instance, there are 26,162 CpGs that have at least one NA, meaning that 396,580 remain.</p>
<pre class="r"><code>wbccData &lt;- assays(methData)$beta
dim(wbccData)</code></pre>
<pre><code>## [1] 422742     56</code></pre>
<pre class="r"><code>wbccData[1:10, 1:2]</code></pre>
<pre><code>##            GSM1179497_5729917059_R01C01 GSM1179498_5729917059_R01C02
## cg01707559                    0.2427893                   0.03954066
## cg03244189                    0.2540326                   0.06285436
## cg04689676                    0.2775596                   0.02124109
## cg14180491                    0.3916605                   0.02714874
## cg00008945                    0.2450289                   0.01050456
## cg00011200                    0.4493624                   0.02083858
## cg00011891                    0.4816901                   0.01569801
## cg00014152                    0.9511915                   0.92834839
## cg00016522                    0.4410385                   0.02458719
## cg00016934                    0.1435423                   0.05071658</code></pre>
<pre class="r"><code>keep &lt;- apply(wbccData, 1, function(x) all(!is.na(x)))
table(keep)</code></pre>
<pre><code>## keep
##  FALSE   TRUE 
##  26162 396580</code></pre>
<pre class="r"><code>wbccData &lt;- wbccData[keep, ]
dim(wbccData)</code></pre>
<pre><code>## [1] 396580     56</code></pre>
<p>Then, known cell percentages are stored along with relevant covariates, such as age and sex. Complete data is then split into a training and test set, in order to build the predictor. It is possible to split the data using <code>sample()</code>, but then there is a risk that patterns in the data will be inherited by the training and test sets. Therefore, we employ stratified splitting using the <code>sample.split()</code> function from <a href="https://cran.r-project.org/web/packages/caTools/index.html"><strong>caTools</strong></a>.</p>
<pre class="r"><code>cellPercentages &lt;- as.data.frame(colData(methData)[ , c(&quot;Neut_Perc&quot;, &quot;Lymph_Perc&quot;,
                                                        &quot;Mono_Perc&quot;, &quot;Eos_Perc&quot;,
                                                        &quot;Baso_Perc&quot;)])
cellPercentages &lt;- apply(cellPercentages, 2, as.numeric)

covariates &lt;- as.data.frame(colData(methData))
covariates &lt;- covariates[ , c(&quot;Age&quot;, &quot;Sex&quot;)]
colnames(covariates) &lt;- c(&quot;Age&quot;, &quot;Sex&quot;)

rownames(covariates) &lt;- rownames(cellPercentages) &lt;- colnames(wbccData) &lt;- colData(methData)$uuid
nas &lt;- apply(cellPercentages, 1, function(x) any(is.na(x)))
complete &lt;- which(!nas)

trainID &lt;- sample.split(complete, SplitRatio=2/3)
testID &lt;- complete[!(complete %in% trainID)]

dataTrain &lt;- wbccData[ , trainID]
covarTrain &lt;- covariates[trainID, ]
cellPercTrain &lt;- cellPercentages[trainID, ]</code></pre>
<p>Now that you have your training and test set, you can use the <code>train()</code> function from <a href="https://github.com/mvaniterson/wbccPredictor"><strong>wbccPredictor</strong></a> to build the predictor. This can then be saved and visualise before testing and use.</p>
<pre class="r"><code>wbccPredictor &lt;- train(dataTrain, covarTrain, cellPerTrain, ncomp=50, validation=&quot;CV&quot;)
save(wbccPredictor)

summary(wbccPredictor)
cumsum(explvar(wbccPredictor))
barplot(cumsum(explvar(wbccPredictor)), las=2, ylab=&quot;Cumulative Variance Explained&quot;)</code></pre>
<p>A validation plot is a method to select the number of components to use with the predictor. In the example below, we use 10 components, and then visualise the results with the <code>plotting()</code> function.</p>
<pre class="r"><code>validationplot(predictor, val.type=&quot;R2&quot;)
predicted &lt;- 10^wbccPredictor$fitted.values[ , , 20]-1
measured &lt;- cellPerTrain

plotting &lt;- function(measured, predicted, xlab=&quot;predicted&quot;, ylab=&quot;measured&quot;)
{
  op &lt;- par(mfcol=c(3,2), mar=c(4,4,3,1))
  for(k in 1:ncol(measured))
  {
    type &lt;- colnames(measured)[k]
    cme &lt;- cor(predicted[ , k], measured[ , k])
    plot(predicted[ , k], measured[ , k], main=paste(type, &quot; (correlation: &quot;, round(cme,4), &quot;)&quot;,
                                                     sep=&quot;&quot;), bty=&quot;n&quot;, pty=&quot;s&quot;)
    abline(lm(measured[ , k]~0+predicted[ , k]), col=2, lty=1, lwd=2)
    abline(0, 1, col=&quot;grey&quot;, lty=1, lwd=2)
    grid()
  }
  par(op)
}

plotting(measured, predicted)</code></pre>
<p>Using the test set, the predictor can be tested before using for <code>prediction()</code>.</p>
<pre class="r"><code>dataTest &lt;- wbccData[ , testID]
covarTest &lt;- covariated[testID, ]
cellPerTest &lt;- cellPercentages[testID, ]

predicted &lt;- prediction(predictor, dataTest, covarTest, ncomp=20)
plotting(cellPerTest, predicted)</code></pre>
</div>
<div id="predict-chronological-age" class="section level3">
<h3>Predict chronological age</h3>
<p>Age can be predicted using Horvath’s or Hannum’s coefficients with <code>agep()</code> from <a href="https://bioconductor.org/packages/release/bioc/html/wateRmelon.html"><strong>wateRmelon</strong></a> <span class="citation">(Pidsley and Schalkwyk 2013)</span>. If you use Hannum’s, you will need to call the coefficients using <code>data(hannumCoef)</code> before prediction.</p>
<pre class="r"><code>library(wateRmelon)
agep &lt;- agep(betas, method=&quot;horvath&quot;)
library(psych)
describe(agep[1:36])</code></pre>
<pre><code>##    vars  n  mean   sd median trimmed  mad   min   max range skew kurtosis
## X1    1 36 56.17 8.64  55.74    56.1 9.66 39.55 71.18 31.62 0.12    -1.12
##      se
## X1 1.44</code></pre>
<pre class="r"><code>describe(agep[37:56])</code></pre>
<pre><code>##    vars  n  mean   sd median trimmed  mad  min   max range skew kurtosis
## X1    1 20 16.54 6.85  14.71   15.68 3.62 8.68 32.44 23.76 1.07     -0.1
##      se
## X1 1.53</code></pre>
<p>The above two summaries are for autopsy and healthy individuals respectively. In the paper <span class="citation">(Slieker et al. 2013)</span>, it states that the mean age for cadavers was 65.5 years with an SD of 7.2. The mean age for healthy volunteers was 28 years with an SD of 6.1. The above shows that age predictions using methylation data can be inaccurate and should not be treated as definitive.</p>
<hr />
</div>
</div>
<div id="checking-sample-relationships" class="section level1">
<h1>Checking Sample Relationships</h1>
<p>Beta-values of the probes containing SNPs can be extracted from the RGset using <a href="http:/bioconductor.org/packages/minfi"><strong>minfi</strong></a>’s <code>getSnpBeta</code> function. These can then be converted to alleles using k-means clustering using the <code>genki()</code> function from <a href="https://bioconductor.org/packages/release/bioc/html/wateRmelon.html"><strong>wateRmelon</strong></a>. This function returns values of disperson for each of three genotype peaks (AA, AB, and BB). which can be used as a performance metric since technical variation would decrease the tightness of the genotypic peaks.</p>
<pre class="r"><code>library(wateRmelon)
snpBetas &lt;- getSnpBeta(RGset)
snpBetasVar &lt;- genki(snpBetas)</code></pre>
<p><a href="http://bioconductor.org/packages/release/bioc/html/omicsPrint.html"><strong>omicsPrint</strong></a> <span class="citation">(Iterson and Heijmans 2018)</span> is a package we developed to detect data linkage errors through inspecting sample relations in multiple omics studies. This example uses data where individuals are unrelated, but if you have data on twins, for example, it would detect that and also show any mismatches.</p>
<p>Included with the package is the <code>hm450.manifest.pop.GoNL</code> data, which stores SNP probe information in a <code>GRanges</code> class object. This is then used to create a subset of the beta values for genotyping.</p>
<pre class="r"><code>library(omicsPrint)
data(hm450.manifest.pop.GoNL)
cpgs &lt;- names(hm450.manifest.pop.GoNL[mcols(hm450.manifest.pop.GoNL)$MASK.snp5.EAS])
cpgs &lt;- na.omit(match(cpgs, rownames(betas)))
omicsBetas &lt;- betas[cpgs,]
omicsBetas[1:10, 1:2]</code></pre>
<pre><code>##            GSM1179497_5729917059_R01C01 GSM1179498_5729917059_R01C02
## cg08477687                   0.59751773                   0.43883985
## cg00645010                   0.28270487                   0.18523023
## cg11422233                   0.18100114                   0.47472823
## cg06402284                   0.12687813                   0.08943764
## cg01551879                   0.04250538                   0.02924197
## cg20788133                   0.87928465                   0.83623337
## cg09139287                   0.20644741                   0.16978382
## cg23100540                   0.32452442                   0.39918395
## cg23999112                   0.65262660                   0.69994102
## cg01062849                   0.84575688                   0.85069259</code></pre>
<p>The function <code>beta2genotype()</code> then genotypes the observations by measuring homozygous or heterozygous alleles at these SNP probes. Lastly <code>alleleSharing()</code> assesses the relationships between different individuals, which can be unrelated, twins, or identical. The results can then be visualised using the <code>inferRelations()</code> function.</p>
<pre class="r"><code>dnamCalls &lt;- beta2genotype(omicsBetas, assayName=&quot;exprs&quot;)
dim(dnamCalls)</code></pre>
<pre><code>## [1] 849  56</code></pre>
<pre class="r"><code>dnamCalls[1:10, 1:2]</code></pre>
<pre><code>##            GSM1179497_5729917059_R01C01 GSM1179498_5729917059_R01C02
## cg03148373                            3                            3
## cg10625579                            3                            3
## cg13917577                            2                            3
## cg14786652                            1                            1
## cg25544075                            1                            1
## cg13167158                            3                            3
## cg12213037                            2                            2
## cg14418633                            3                            3
## cg23015118                            1                            1
## cg08121686                            1                            3</code></pre>
<pre class="r"><code>omicsData &lt;- alleleSharing(dnamCalls, verbose=TRUE)</code></pre>
<pre><code>## Hash relations</code></pre>
<pre><code>## Pruning 849 SNPs ...</code></pre>
<pre><code>## 0 SNPs removed because of low call rate!</code></pre>
<pre><code>## 0 samples removed because too few SNPs called!</code></pre>
<pre><code>## Using 849 polymorphic SNPs to determine allele sharing.</code></pre>
<pre><code>## Running `square` IBS algorithm!</code></pre>
<pre><code>## 57 of 1596 (3.57%) ...</code></pre>
<pre class="r"><code>mismatches &lt;- inferRelations(omicsData)</code></pre>
<p><img src="05_Miscellaneous_files/figure-html/613genotype-1.png" width="672" /></p>
<hr />
</div>
<div id="imputating-na-values" class="section level1">
<h1>Imputating NA Values</h1>
<p>Several algorithms do not allow NA’s but beta-values and or M-values can contain NA’s after preprocessing. Either because some probes/CpG were specifically set NA or because of transformation from intensities to beta or M-values. The <a href="https://bioconductor.org/packages/release/bioc/html/impute.html"><strong>impute</strong></a> <span class="citation">(Troyanskaya et al. 2001)</span> package can be used to impute these values. Below, we use the knn approach implemented by <code>impute.knn()</code> from this package.</p>
<pre class="r"><code>library(impute)
betas &lt;- impute.knn(as.matrix(betas))$data</code></pre>
<hr />
</div>
<div id="probe-annotation" class="section level1">
<h1>Probe Annotation</h1>
<p>Our package also contains a <code>cpgInfo()</code> function, which can be used to map CpG probes to their nearest genes. This utilises the <a href="http://bioconductor.statistik.tu-dortmund.de/packages/3.6/data/annotation/html/TxDb.Hsapiens.UCSC.hg19.knownGene.html"><strong>TxDb.Hsapiens.UCSC.hg19.knownGene</strong></a> package, which accesses the USCS annotation databases.</p>
<pre class="r"><code>cpgs &lt;- rownames(betas)
cpgInfo &lt;- cpgInfo(cpgs, TxDb=&quot;TxDb.Hsapiens.UCSC.hg19.knownGene&quot;)</code></pre>
<pre><code>## Fetching coordinates for hg19...</code></pre>
<pre><code>## &#39;select()&#39; returned many:1 mapping between keys and columns</code></pre>
<pre class="r"><code>cpgInfo[1:10, 1:7]</code></pre>
<pre><code>##            seqnames    start      end  width strand gene_id   SYMBOL
## cg00050873     chrY  9215731  9368285 152555      +  728137    TSPY3
## cg00212031     chrY 21094585 21239302 144718      -   83869   TTTY14
## cg00213748     chrY  8551411  8551919    509      -  252950   TTTY18
## cg00214611     chrY 15815447 15817902   2456      +    9087   TMSB4Y
## cg00455876     chrY  9215731  9368285 152555      +  728137    TSPY3
## cg01707559     chrY  6778727  6959724 180998      +   90665    TBL1Y
## cg02004872     chrY 15815447 15817902   2456      +    9087   TMSB4Y
## cg02011394     chrY  9187189  9362885 175697      -  252946 FAM197Y2
## cg02050847     chrY 22917954 22942918  24965      +  140032   RPS4Y2
## cg02233190     chrY 22737611 22755040  17430      +    9086   EIF1AY</code></pre>
<hr />
</div>
<div id="dmr-finder" class="section level1">
<h1>DMR finder</h1>
<p>We have implemented a differentially methylated region (DMR) finder in the function <code>DMRfinder()</code> <span class="citation">(Slieker et al. 2013)</span>. First, genomic features are extracted from the relevant <code>FeatureDb</code> as a <code>GRanges</code> object.</p>
<pre class="r"><code>feats &lt;- features(FDb.InfiniumMethylation.hg19)
regions &lt;- feats[seqnames(feats) %in% c(&quot;chr21&quot;, &quot;chr22&quot;)]
mcols(regions)  &lt;- NULL
mcols(regions)$crit &lt;- rbinom(length(regions), 1, prob=0.2)

##input GRanges
(dmrsR &lt;- DMRfinder(regions))

##input named-vector
dmps &lt;- mcols(regions)$crit
names(dmps) &lt;- names(regions)
(dmrsV &lt;- DMRfinder(dmps))

##bed-like data.frame
regions &lt;- as.data.frame(regions)
regions &lt;- regions[, c(&quot;seqnames&quot;, &quot;start&quot;, &quot;crit&quot;)]
colnames(regions) &lt;- c(&quot;chr&quot;, &quot;pos&quot;, &quot;crit&quot;)
(dmrsD &lt;- DMRfinder(regions))

##all equal
length(dmrsR)
length(dmrsV)
length(dmrsD)

head(dmrsR)
head(dmrsV)
head(dmrsD)

dmrsR == dmrsV
dmrsR == dmrsD
dmrsV == dmrsD</code></pre>
<hr />
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references">
<div id="ref-Aryee2014">
<p>Aryee, M. J., A. E. Jaffe, H. Corrada-Bravo, C. Ladd-Acosta, A. P. Feinberg, K. D. Hansen, and R. A. Irizarry. 2014. “Minfi: a flexible and comprehensive Bioconductor package for the analysis of Infinium DNA methylation microarrays.” <em>Bioinformatics</em>.</p>
</div>
<div id="ref-Houseman2012">
<p>Houseman, E. A., W. P. Accomando, D. C. Koestler, B. C. Christensen, C. J. Marsit, H. H. Nelson, J. K. Wiencke, and K. T. Kelsey. 2012. “DNA methylation arrays as surrogate measures of cell mixture distribution.” <em>BMC Bioinformatics</em> 13: 86.</p>
</div>
<div id="ref-Iterson2018">
<p>Iterson, Cats van, M., and B.T. Heijmans. 2018. “omicsPrint: Detection of data linkage errors in multiple omics studies.” <em>Bioinformatics</em>.</p>
</div>
<div id="ref-Jaffe2014">
<p>Jaffe, A. E., and R. A. Irizarry. 2014. “Accounting for cellular heterogeneity is critical in epigenome-wide association studies.” <em>Genome Biol.</em> 15 (2): R31.</p>
</div>
<div id="ref-Pidsley2013">
<p>Pidsley, Wong, R., and C. Schalkwyk. 2013. “A data-driven approach to preprocessing Illumina 450K methylation array data.” <em>BMC Genomics</em> 14: 293.</p>
</div>
<div id="ref-Slieker2013">
<p>Slieker, R. C., S. D. Bos, J. J. Goeman, J. V. Bovee, R. P. Talens, R. van der Breggen, H. E. Suchiman, et al. 2013. “Identification and systematic annotation of tissue-specific differentially methylated regions using the Illumina 450k array.” <em>Epigenetics Chromatin</em> 6 (1): 26.</p>
</div>
<div id="ref-Troyanskaya2001">
<p>Troyanskaya, O., M. Cantor, G. Sherlock, P. Brown, T. Hastie, R. Tibshirani, D. Botstein, and R. B. Altman. 2001. “Missing value estimation methods for DNA microarrays.” <em>Bioinformatics</em> 17 (6): 520–25.</p>
</div>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
