<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title></title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/lumen.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #ffffff; color: #1f1c1b; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; background-color: #ffffff; color: #a0a0a0; border-right: 1px solid #a0a0a0; }
td.sourceCode { padding-left: 5px; }
pre, code { color: #1f1c1b; background-color: #ffffff; }
code > span.kw { color: #1f1c1b; font-weight: bold; } /* Keyword */
code > span.dt { color: #0057ae; } /* DataType */
code > span.dv { color: #b08000; } /* DecVal */
code > span.bn { color: #b08000; } /* BaseN */
code > span.fl { color: #b08000; } /* Float */
code > span.cn { color: #aa5500; } /* Constant */
code > span.ch { color: #924c9d; } /* Char */
code > span.sc { color: #3daee9; } /* SpecialChar */
code > span.st { color: #bf0303; } /* String */
code > span.vs { color: #bf0303; } /* VerbatimString */
code > span.ss { color: #ff5500; } /* SpecialString */
code > span.im { color: #ff5500; } /* Import */
code > span.co { color: #898887; } /* Comment */
code > span.do { color: #607880; } /* Documentation */
code > span.an { color: #ca60ca; } /* Annotation */
code > span.cv { color: #0095ff; } /* CommentVar */
code > span.ot { color: #006e28; } /* Other */
code > span.fu { color: #644a9b; } /* Function */
code > span.va { color: #0057ae; } /* Variable */
code > span.cf { color: #1f1c1b; font-weight: bold; } /* ControlFlow */
code > span.op { color: #1f1c1b; } /* Operator */
code > span.bu { color: #644a9b; font-weight: bold; } /* BuiltIn */
code > span.ex { color: #0095ff; font-weight: bold; } /* Extension */
code > span.pp { color: #006e28; } /* Preprocessor */
code > span.at { color: #0057ae; } /* Attribute */
code > span.re { color: #0057ae; } /* RegionMarker */
code > span.in { color: #b08000; } /* Information */
code > span.wa { color: #bf0303; } /* Warning */
code > span.al { color: #bf0303; font-weight: bold; } /* Alert */
code > span.er { color: #bf0303; text-decoration: underline; } /* Error */
code > span. { color: #1f1c1b; } /* Normal */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' || rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 54px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 59px;
  margin-top: -59px;
}
.section h2 {
  padding-top: 59px;
  margin-top: -59px;
}
.section h3 {
  padding-top: 59px;
  margin-top: -59px;
}
.section h4 {
  padding-top: 59px;
  margin-top: -59px;
}
.section h5 {
  padding-top: 59px;
  margin-top: -59px;
}
.section h6 {
  padding-top: 59px;
  margin-top: -59px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->



<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">DNAmArray</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="01_SampleQualityControl.html">Sample-level QC</a>
</li>
<li>
  <a href="02_Visualization.html">Visualizations</a>
</li>
<li>
  <a href="03_Normalization.html">Normalization</a>
</li>
<li>
  <a href="04_ProbeFiltering.html">Probe Filtering</a>
</li>
<li>
  <a href="05_Miscellaneous.html">Predictions</a>
</li>
<li>
  <a href="06_EWAS.html">EWAS</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="about.html">About</a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">




</div>


<hr />
<div id="imputation" class="section level1">
<h1>Imputation</h1>
<p>Methylation profiles often contain multiple missing values, which can be assumed to be missing at random (MAR), since they are likely due to random experimental and technology-related errors, rather than associated with methylation status.</p>
<p>Imputation of these values is beneficial for multiple algorithms, but its importance is highlighted in the use of predictors that rely on values from only a subset of CpGs. In these instances, the effect of a few missing sites could vastly alter estimated age, for example.</p>
<p>DNA methylation values represent a limited-range continuous variable, for which many standard imputation methods are theoretically suitable. However, they struggle with larger datasets due to a lack of computational efficiency. For this reason, specific strategies have been developed to handle missing methylation data <span class="citation">(Mazumder et al. 2010, <span class="citation">Josse and Husson (2012)</span>, <span class="citation">Di Lena et al. (2019)</span>)</span>.</p>
<p>The method that we advise using is <a href="https://github.com/pdilena/methyLImp"><strong>MethyLImp</strong></a> <span class="citation">(Di Lena et al. 2019)</span>, and we are in the process of developing a parallelized version of this for DNAmArray. This iterative algorithm exploits the high inter-sample correlation seen in methylation data <span class="citation">(L. Zhang et al. 2017)</span>, capturing it using linear regression. This method is both computationally efficient and has been shown to perform better than all current alternatives, whilst not requiring post-imputation truncation <span class="citation">(Di Lena et al. 2019)</span>.</p>
<p>Until the parallelized version is available, we advise using <code>imputePCA()</code> from <a href="https://www.rdocumentation.org/packages/missMDA/versions/1.14"><strong>missMDA</strong></a> <span class="citation">(Josse and Husson 2012)</span>. This performs well for its small computation time, and does not suffer from the beta-value bias that <code>impute.knn()</code> has been shown to <span class="citation">(Di Lena et al. 2019)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(<span class="kw">is.na</span>(betas))</code></pre></div>
<pre><code>## [1] 42832</code></pre>
<p>After filtering and preprocessing, our beta-value matrix has 42,832 missing values. Using the code below, we can impute them by implementing a low-rank approximation version of the iterative EM-PCA algorithm <span class="citation">(Dempster, Laird, and Rubin 1977)</span>. Since this function can impute values outside the [0,1] range of beta-values, we apply a simple post-imputation truncation of the overflowed values. This has been shown not to significantly affect the accuracy <span class="citation">(Di Lena et al. 2019)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(missMDA)
betas &lt;-<span class="st"> </span><span class="kw">imputePCA</span>(betas)
betas &lt;-<span class="st"> </span>betas<span class="op">$</span>completeObs

betas[betas<span class="op">&lt;</span><span class="dv">0</span>] &lt;-<span class="st"> </span><span class="dv">0</span>
betas[betas<span class="op">&gt;</span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">1</span></code></pre></div>
<hr />
</div>
<div id="phenotype-prediction" class="section level1">
<h1>Phenotype Prediction</h1>
<p>It can be useful to predict phenotypes in your data, either for comparison to assumed categories or to help impute missing values. We are in the process of creating predictors for sample cell composition, sex, age, and smoking status. These will either be reference-based predictors using the large BIOS data, which includes samples from 6 dutch cohorts and over 4000 individuals, or ones built using reference-free or semi-supervised methods.</p>
<p>When created and distributed within this package, you will be able to use them to predict phenotypes in your own datasets. Meanwhile, below some current methods are describe to predict phenotypes in your data.</p>
<div id="predict-white-blood-cell-composition" class="section level3">
<h3>Predict White Blood Cell Composition</h3>
<p>White blood cell count can be predicted using Houseman’s partial least squares method <span class="citation">(Houseman et al. 2012)</span> implemented in <a href="http://bioconductor.org/packages/minfi"><strong>minfi</strong></a> <span class="citation">(Aryee et al. 2014)</span> by the <code>estimateCellCounts()</code> function. This implements a calibration algorithm for deconvoluting heterogenous tissue sources, such as blood, and returns a matrix of composition estimates across all samples and cell types.</p>
</div>
<div id="predict-sex" class="section level3">
<h3>Predict Sex</h3>
<p>The <a href="https://github.com/molepi/DNAmArray"><strong>DNAmArray</strong></a> package contains a <code>getSex.DNAmArray()</code> function, which predicts the sex of your observations by inspecting intensities of X-chromosome signals. We use the <code>getBeta()</code> function from <a href="https://bioconductor.org/packages/release/bioc/html/minfi.html"><strong>minfi</strong></a> as before to get the beta-value matrix and then use this to predict sex. Since some filtered probes may be used by the sex prediction function, we recalculate the beta matrix before prediction.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">betas_sex &lt;-<span class="st"> </span><span class="kw">getBeta</span>(RGset)
mid &lt;-<span class="st"> </span><span class="kw">match</span>(<span class="kw">colnames</span>(betas_sex), targets<span class="op">$</span>Basename)

predictedSex &lt;-<span class="st"> </span><span class="kw">as.factor</span>(<span class="kw">getSex.DNAmArray</span>(betas_sex))
assumedSex &lt;-<span class="st"> </span>targets<span class="op">$</span>sex[mid]

<span class="kw">table</span>(predictedSex, assumedSex)</code></pre></div>
<pre><code>##             assumedSex
## predictedSex Female Male
##       Female     55    0
##       Male        0   83</code></pre>
<p>As you can see, this is complete data, but the predicted and assumed sexes are identical. This means that we can feel increased confidence that no incorrect labelling or mix-ups are present in this variable.</p>
</div>
<div id="predict-chronological-age" class="section level3">
<h3>Predict chronological age</h3>
<p>Age can be predicted using Horvath’s or Hannum’s coefficients with <code>agep()</code> from <a href="https://bioconductor.org/packages/release/bioc/html/wateRmelon.html"><strong>wateRmelon</strong></a>. If you use Hannum’s, you will need to call the coefficients using <code>data(hannumCoef)</code> before prediction. The predicted and assumed ages are then combined into a data frame that can be used to visualize the results.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(wateRmelon)
predictedAge &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(<span class="kw">agep</span>(betas, <span class="dt">method=</span><span class="st">&quot;horvath&quot;</span>))
assumedAge &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(targets<span class="op">$</span>age[mid])

ages &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">Assumed=</span>assumedAge, <span class="dt">Predicted=</span>predictedAge)
<span class="kw">head</span>(ages)</code></pre></div>
<pre><code>##   Assumed Predicted
## 1    17.3 13.072017
## 2    11.3  6.820242
## 3     9.5  4.511927
## 4    15.0 13.046026
## 5     6.7  5.324749
## 6     8.3  6.697246</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(ages, <span class="kw">aes</span>(<span class="dt">x=</span>Assumed, <span class="dt">y=</span>Predicted)) <span class="op">+</span><span class="st"> </span><span class="kw">ggtitle</span>(<span class="st">&quot;Assumed vs. Predicted Age&quot;</span>) <span class="op">+</span><span class="st"> </span>th3 <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">shape=</span><span class="dv">16</span>, <span class="dt">color=</span><span class="st">&quot;#158cba&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">geom_smooth</span>(<span class="dt">method=</span>lm, <span class="dt">color=</span><span class="st">&quot;#D67D87&quot;</span>)</code></pre></div>
<p><img src="05_Miscellaneous_files/figure-html/610plot-1.png" width="672" /></p>
<p>The above graph shows that this prediction follows the general trend of the assumed ages, however the residuals are quite large. It may be possible to develop an improved predictor <span class="citation">(Q. Zhang et al. 2018)</span>, and we plan to implement this.</p>
<hr />
</div>
</div>
<div id="rangedsummarizedexperiment" class="section level1">
<h1><code>RangedSummarizedExperiment</code></h1>
<p>Moving further into the pipeline, it will be necessary to have our methylation data stored in a <a href="http://bioconductor.org/packages/SummarizedExperiment"><code>RangedSummarizedExperiment</code></a> class object. Designed to handle microarray data, this class stores observations from multiple samples alongside relevant meta-data, and ensures that both features and phenotypes are kept in-sync when subsetting.</p>
<p>This matrix-like container is organised with rows representing features, such as genes or exons, which can be accessed using <code>rowRanges()</code>. This function calls a <code>GRanges</code> object describing features and their attributes. The columns of the <code>RangedSummarizedExperiment</code> store information about each sample, and this can be accessed using <code>colData()</code>.</p>
<p>Lastly, each assay is represented in the third dimension of this matrix-like object and can be shown using the <code>assays()</code> function. Meta-data is then linked to this combination of data frames, and can be accessed with the <code>metadata()</code> command.</p>
<div id="creating-a-rangedsummarizedexperiment" class="section level3">
<h3>Creating a <code>RangedSummarizedExperiment</code></h3>
<p>The <a href="https://bioconductor.org/packages/release/data/annotation/html/FDb.InfiniumMethylation.hg19.html"><strong>FDb.InfiniumMethylation.hg19</strong></a> package contains probe annotations, which can be extracted using the <code>getPlatform()</code> function. To ensure that we apply the previous probe filtering, we use <code>match()</code> to keep only the relevant information.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(FDb.InfiniumMethylation.hg19)
rowRanges &lt;-<span class="st"> </span><span class="kw">getPlatform</span>(<span class="dt">platform=</span><span class="st">&quot;HM450&quot;</span>, <span class="dt">genome=</span><span class="st">&quot;hg19&quot;</span>)</code></pre></div>
<pre><code>## Fetching coordinates for hg19...</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">rows &lt;-<span class="st"> </span><span class="kw">match</span>(<span class="kw">rownames</span>(betas), <span class="kw">names</span>(rowRanges))
rowRanges &lt;-<span class="st"> </span>rowRanges[rows]

rowRanges[,<span class="dv">3</span><span class="op">:</span><span class="dv">4</span>]</code></pre></div>
<pre><code>## GRanges object with 423586 ranges and 2 metadata columns:
##                   seqnames            ranges strand | channel platform
##                      &lt;Rle&gt;         &lt;IRanges&gt;  &lt;Rle&gt; |   &lt;Rle&gt;    &lt;Rle&gt;
##        cg01707559     chrY   6778695-6778696      * |     Red    HM450
##        cg03244189     chrY 21238472-21238473      * |     Grn    HM450
##        cg04792227     chrY 17568097-17568098      * |     Red    HM450
##        cg14180491     chrY 15016705-15016706      * |     Grn    HM450
##        cg25032547     chrY 14773536-14773537      * |     Red    HM450
##               ...      ...               ...    ... .     ...      ...
##   ch.22.44116734F    chr22          45738070      * |    Both    HM450
##     ch.22.909671F    chr22          46114168      * |    Both    HM450
##   ch.22.46830341F    chr22          48451677      * |    Both    HM450
##    ch.22.1008279F    chr22          48731367      * |    Both    HM450
##   ch.22.47579720R    chr22          49193714      * |    Both    HM450
##   -------
##   seqinfo: 24 sequences from hg19 genome</code></pre>
<p>Now that we have our annotations, we can combine them with our data using the <a href="https://bioconductor.org/packages/release/bioc/html/SummarizedExperiment.html"><strong>SummarizedExperiment</strong></a> package. After ensuring that any column subsetting is accounted for, we extract the <code>colData()</code> from our <code>RGset</code>. Finally, the beta values, probe annotations, and sample information are combined into a <code>RangedSummarizedExperiment</code> object using the <code>SummarizedExperiment()</code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(SummarizedExperiment)

cols &lt;-<span class="st"> </span><span class="kw">match</span>(<span class="kw">colnames</span>(betas), <span class="kw">colnames</span>(RGset))
colData &lt;-<span class="st"> </span><span class="kw">DataFrame</span>(<span class="kw">colData</span>(RGset[, cols])<span class="op">@</span>listData)

methData &lt;-<span class="st"> </span><span class="kw">SummarizedExperiment</span>(<span class="dt">assays=</span><span class="kw">SimpleList</span>(<span class="dt">betas=</span>betas),
                                 <span class="dt">rowRanges=</span>rowRanges,
                                 <span class="dt">colData=</span>colData)
methData</code></pre></div>
<pre><code>## class: RangedSummarizedExperiment 
## dim: 423586 138 
## metadata(0):
## assays(1): betas
## rownames(423586): cg01707559 cg03244189 ... ch.22.1008279F
##   ch.22.47579720R
## rowData names(10): addressA addressB ... probeEnd probeTarget
## colnames(138): GSM3092700_9985178096_R01C01
##   GSM3092701_9985178127_R03C02 ... GSM3093566_9020331152_R05C01
##   GSM3093567_9020331152_R06C01
## colData names(35): title public_date ... Basename filenames</code></pre>
You can read more about <a href="http://bioconductor.org/packages/SummarizedExperiment"><strong>SummarizedExperiment</strong></a> from the following resources:
<ul>
<li>
<a href="http://bioconductor.org/packages/release/bioc/vignettes/SummarizedExperiment/inst/doc/SummarizedExperiment.html">package vignette</a>
</li>
<li>
<a href="http://bioconductor.org/help/course-materials/2012/BiocEurope2012/SummarizedExperiment.pdf">course material</a>
</li>
<li>
<a href="http://www.nature.com/nmeth/journal/v12/n2/full/nmeth.3252.html">BioConductor nature paper</a>
</li>
</ul>
<hr />
</div>
</div>
<div id="checking-sample-relationships" class="section level1">
<h1>Checking Sample Relationships</h1>
<p>Beta-values of the probes containing SNPs can be extracted from the RGset using <a href="http:/bioconductor.org/packages/minfi"><strong>minfi</strong></a>’s <code>getSnpBeta</code> function. These can then be converted to alleles using k-means clustering using the <code>genki()</code> function from <a href="https://bioconductor.org/packages/release/bioc/html/wateRmelon.html"><strong>wateRmelon</strong></a>. This function returns values of disperson for each of three genotype peaks (AA, AB, and BB). which can be used as a performance metric since technical variation would decrease the tightness of the genotypic peaks.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(wateRmelon)
snpBetas &lt;-<span class="st"> </span><span class="kw">getSnpBeta</span>(RGset)
snpBetasVar &lt;-<span class="st"> </span><span class="kw">genki</span>(snpBetas)</code></pre></div>
<p><a href="http://bioconductor.org/packages/release/bioc/html/omicsPrint.html"><strong>omicsPrint</strong></a> <span class="citation">(Van Iterson et al. 2018)</span> is a package we developed to detect data linkage errors through inspecting sample relations in multiple omics studies. This example uses data where individuals are unrelated, but if you have data on twins, for example, it would detect that and also show any mismatches.</p>
<p>Included with the package is the <code>hm450.manifest.pop.GoNL</code> data, which stores SNP probe information in a <code>GRanges</code> class object. This is then used to create a subset of the beta values for genotyping.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(omicsPrint)
<span class="kw">data</span>(hm450.manifest.pop.GoNL)
cpgs &lt;-<span class="st"> </span><span class="kw">names</span>(hm450.manifest.pop.GoNL[<span class="kw">mcols</span>(hm450.manifest.pop.GoNL)<span class="op">$</span>MASK.snp5.EAS])
cpgs &lt;-<span class="st"> </span><span class="kw">na.omit</span>(<span class="kw">match</span>(cpgs, <span class="kw">rownames</span>(betas_sex)))
omicsBetas &lt;-<span class="st"> </span>betas_sex[cpgs,]
omicsBetas[<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>]</code></pre></div>
<pre><code>##            GSM3092700_9985178096_R01C01 GSM3092701_9985178127_R03C02
## cg08477687                   0.57171216                   0.57340242
## cg00645010                   0.24643615                   0.32681420
## cg11422233                   0.14063955                   0.13474866
## cg06402284                   0.06962435                   0.08141825
## cg01551879                   0.03872920                   0.04622407
## cg20788133                   0.80971844                   0.83957784
## cg09139287                   0.56352808                   0.32561464
## cg23100540                   0.32947931                   0.38723776
## cg23999112                   0.75425515                   0.76118107
## cg01062849                   0.90289728                   0.90511892</code></pre>
<p>The function <code>beta2genotype()</code> then genotypes the observations by measuring homozygous or heterozygous alleles at these SNP probes. Lastly <code>alleleSharing()</code> assesses the relationships between different individuals, which can be unrelated, twins, or identical. The results can then be visualised using the <code>inferRelations()</code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dnamCalls &lt;-<span class="st"> </span><span class="kw">beta2genotype</span>(omicsBetas, <span class="dt">assayName=</span><span class="st">&quot;exprs&quot;</span>)
<span class="kw">dim</span>(dnamCalls)</code></pre></div>
<pre><code>## [1] 750 138</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dnamCalls[<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>]</code></pre></div>
<pre><code>##            GSM3092700_9985178096_R01C01 GSM3092701_9985178127_R03C02
## cg12213037                            2                            3
## cg19405842                            2                            1
## cg01296877                            2                            3
## cg21783012                            2                            2
## cg10091792                            3                            3
## cg04882216                            3                            3
## cg26422465                            2                            1
## cg00345083                            2                            2
## cg15075357                            1                            1
## cg13928473                            1                            3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">omicsData &lt;-<span class="st"> </span><span class="kw">alleleSharing</span>(dnamCalls, <span class="dt">verbose=</span><span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## Hash relations</code></pre>
<pre><code>## Pruning 750 SNPs ...</code></pre>
<pre><code>## 0 SNPs removed because of low call rate!</code></pre>
<pre><code>## 0 samples removed because too few SNPs called!</code></pre>
<pre><code>## Using 750 polymorphic SNPs to determine allele sharing.</code></pre>
<pre><code>## Running `square` IBS algorithm!</code></pre>
<pre><code>## 139 of 9591 (1.45%) ...</code></pre>
<pre><code>## 8851 of 9591 (92.28%) ...</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mismatches &lt;-<span class="st"> </span><span class="kw">inferRelations</span>(omicsData)</code></pre></div>
<p><img src="05_Miscellaneous_files/figure-html/613genotype-1.png" width="672" /></p>
<p>Since there are no twins or relatives in our data, all observations are shown as unrelated. In data with sample relationships, this would be shown in the above graph as green or black clusters <span class="citation">(Van Iterson et al. 2018)</span>. It is important to carry out this type of visualization before probe-filtering as otherwise the genotyping will be based on very few SNPs.</p>
<hr />
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references">
<div id="ref-Feinberg2014">
<p>Aryee, Martin J., Andrew E. Jaffe, Hector Corrada-Bravo, Christine Ladd-Acosta, Andrew P. Feinberg, Kasper D. Hansen, and Rafael A. Irizarry. 2014. “Minfi: A flexible and comprehensive Bioconductor package for the analysis of Infinium DNA methylation microarrays.” <em>Bioinformatics</em> 30 (10). Oxford University Press: 1363–9. doi:<a href="https://doi.org/10.1093/bioinformatics/btu049">10.1093/bioinformatics/btu049</a>.</p>
</div>
<div id="ref-Dempster1977">
<p>Dempster, A P,; N M Laird, and; D B Rubin. 1977. “Maximum Likelihood from Incomplete Data via the EM Algorithm.” 1. Vol. 39. <a href="http://web.mit.edu/6.435/www/Dempster77.pdf" class="uri">http://web.mit.edu/6.435/www/Dempster77.pdf</a>.</p>
</div>
<div id="ref-DiLena2019">
<p>Di Lena, Pietro, Claudia Sala, Andrea Prodi, and Christine Nardini. 2019. “Missing value estimation methods for DNA methylation data.” Edited by Jonathan Wren. <em>Bioinformatics</em>, February. doi:<a href="https://doi.org/10.1093/bioinformatics/btz134">10.1093/bioinformatics/btz134</a>.</p>
</div>
<div id="ref-Houseman2012">
<p>Houseman, Eugene Andres, William P Accomando, Devin C Koestler, Brock C Christensen, Carmen J Marsit, Heather H Nelson, John K Wiencke, and Karl T Kelsey. 2012. “DNA methylation arrays as surrogate measures of cell mixture distribution.” <em>BMC Bioinformatics</em> 13 (1). BioMed Central: 86. doi:<a href="https://doi.org/10.1186/1471-2105-13-86">10.1186/1471-2105-13-86</a>.</p>
</div>
<div id="ref-Josse2012">
<p>Josse, Julie, and François Husson. 2012. “Handling missing values in exploratory multivariate data analysis methods.” <a href="https://hal.archives-ouvertes.fr/hal-00811888" class="uri">https://hal.archives-ouvertes.fr/hal-00811888</a>.</p>
</div>
<div id="ref-Mazumder2010">
<p>Mazumder, Rahul, Trevor Hastie, Hastie@stanford Edu, Robert Tibshirani, Tibs@stanford Edu, and Tommi Jaakkola. 2010. “Spectral Regularization Algorithms for Learning Large Incomplete Matrices.” Vol. 11. <a href="https://web.stanford.edu/{~}hastie/Papers/mazumder10a.pdf" class="uri">https://web.stanford.edu/{~}hastie/Papers/mazumder10a.pdf</a>.</p>
</div>
<div id="ref-VanIterson2018">
<p>Van Iterson, Maarten, Davy Cats, Paul Hop, and Bastiaan T Heijmans. 2018. “OmicsPrint: Detection of data linkage errors in multiple omics studies.” Edited by Oliver Stegle. <em>Bioinformatics</em> 34 (12). Oxford University Press: 2142–3. doi:<a href="https://doi.org/10.1093/bioinformatics/bty062">10.1093/bioinformatics/bty062</a>.</p>
</div>
<div id="ref-Zhang2017">
<p>Zhang, Ling, Wen Jun Xie, Sirui Liu, Luming Meng, Chan Gu, and Yi Qin Gao. 2017. “DNA Methylation Landscape Reflects the Spatial Organization of Chromatin in Different Cells.” <em>Biophysical Journal</em> 113 (7). The Biophysical Society: 1395. doi:<a href="https://doi.org/10.1016/J.BPJ.2017.08.019">10.1016/J.BPJ.2017.08.019</a>.</p>
</div>
<div id="ref-Zhang2018">
<p>Zhang, Qian, Costanza L. Vallerga, Rosie M Walker, Tian Lin, Anjali K. Henders, Grant W. Montgomery, Ji He, et al. 2018. “Improved prediction of chronological age from DNA methylation limits it as a biomarker of ageing.” <em>bioRxiv</em>, October. Cold Spring Harbor Laboratory, 327890. doi:<a href="https://doi.org/10.1101/327890">10.1101/327890</a>.</p>
</div>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
